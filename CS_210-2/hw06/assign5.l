(defun flat (x) (mapcan #'(lambda (z) (cond ((listp z) (flat z))
                                                 (T (list z))
)) x))

(defun the-family () 
	(setq l (remove-duplicates (flat family)))
	(sort l 'string-lessp)
)

(defun father(x)
	(setq l	(mapcar #'(lambda (z) 
				(if (eq x (car z)) (cdr(cdr z)))
			  ) 
		family)
	)
	(delete-duplicates l)
	(delete nil l)
	(flat l)
	(car (flat l))
)

(defun mother(x)
	(setq l	(mapcar #'(lambda (z) 
				(if (eq x (car z)) (car(cdr z)))
			  ) 
		family)
	)
	(delete-duplicates l)
	(delete nil l)
	(flat l)
	(car (flat l))
)

(defun parents(x)
	(setq l (mapcar #'(lambda (z) 
				(if (eq x (car z)) (cdr z))
			  ) 
		family)
	)
	(setq l (flat l))
	(delete-duplicates l)
	(delete nil l)
	(flat l)
)

(defun grandparents (x)
	(setq l (mapcar #'(lambda (z)
			z
			  )
		(list (parents (father x)) (parents (mother x))))
	)
	(setq l (flat l))
	(delete-duplicates l)
)

(defun children (x)
	(setq l (mapcar #'(lambda (z)
				(if(member x (parents (car z))) (car z)) 
			  )
		family)
	)
	(flat l)
)

(defun full-siblings(x)
	(setq l (mapcar #'(lambda (z) 
				(if (equal (parents x) (parents (car z))) (car z))
			  ) 
		family)
	)
	(setq l (flat l))
	(delete x l)
)

(defun siblings(x)
	(setq l (children (father x)))
	(append l (children (mother x)))
	;(delete-duplicates l)
	;(delete x l)
)

(defun half-siblings(x)
	(set-difference (siblings x) (full-siblings x))
)

(defun aunts-uncles (x)
	(setq l (mapcar #'(lambda (z)
				(siblings z)
			  )
		(parents x))
	)
	(setq l (flat l))
	(delete-duplicates l)
)

(defun first-cousins (x)
	(setq l (mapcar #'(lambda (z)
				(children z)
			  )
		(aunts-uncles x))
	)
	(setq l (flat l))
	(delete-duplicates l)
)

(defun ancestors (x)
	(if (not (eq x nil)) (setq l (list (mother x) (father x) (ancestors (father x)) (ancestors (mother x))) ) )
	(flat l)
)

(defun descendants (x)
	(setq l (mapcar #'(lambda (z)
			  z
			  )
		(children x))
	)
	(setq l (flat l))
	(if l
		(setq l2 (mapcar #'(lambda (z)
				z;(descendants z)
				  )
		 	l)
		)
	)
)

(defun matep (x y)
	(setq l (mapcar #'(lambda (z)
				(if (member z (children y)) T)
			  )
		(children x))
	)
	(flat l)
	(if (eq x y) nil (if (member T l) T) )
)

(defun siblingp (x y)
	(setq l (mapcar #'(lambda (z)
				(if (member z (parents y)) z)
			  )
		(parents x))
	)
	(flat l)
	;(if (eq x y) nil (if (member T l) T) )
)

