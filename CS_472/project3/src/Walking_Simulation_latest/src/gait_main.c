/*******************************************************************************

   FORMAIN.C

   Author: Peter Loan

   Date of creation: 22-OCT-95

   Copyright (c) 1996 MusculoGraphics, Inc.
   All rights reserved.

   Description: This file contains the main routine for a forward dynamics
		simulation, and several other utility routines that are
		independent of the musculoskeletal model in the simulation.
		You may want to copy this file and make changes to it as needed
		for your particular simulation.

*******************************************************************************/

#include "universal.h"
#include "functions.h"
#include "defines.h"

/*************** DEFINES (for this file only) *********************************/

#define BAUMGARTE_STAB 20


/*************** STATIC GLOBAL VARIABLES (for this file only) *****************/


/**************** GLOBAL VARIABLES (used in only a few files) *****************/
extern SDModelStruct sdm;


/*************** EXTERNED VARIABLES (declared in another file) ****************/



/*************** PROTOTYPES for STATIC FUNCTIONS (for this file only) *********/
static void init_motion(void);


main(void)
{

   int generate_motion_file = 1; /* 1=yes, 0=no */

   int i, j, nstep = 750, fcnt, err, *lock, which;
   double t = 0.0, dt = 0.0022, ctol = 0.0000001, tol = 0.0001;
   double *y, *dy, *work, param[1], step;
   double *joint_torque,*joint_power;
   double mus_pwr[nstep][NMUS],track[nstep][20];

   double tx_var,ankavel,temp3[3],temp2[3];

   double zero[3],postemp[3],veltemp[3],angveltemp[3],segme_total[12];
   double masstemp, inertemp[3][3],pos[NBOD];
   double inertia[NBOD],mass[NBOD],vel[NBOD][3],angvel[NBOD];

   FILE *fp_motion, *fp_sim, *fp_exc, *fp_init, *fp_state, *fp_shoe, *fp_pwr;

   int shoe_array_size=132;
   static double grf[1000][6];
   ShoeStruct* ss;
   MuscleStruct* ms;

   sdm.shoe_element = (ShoeStruct*)simm_malloc(shoe_array_size*sizeof(ShoeStruct));

/*
   printf("\nDynamics Pipeline Forward Simulation.\n\n");
*/
   init_qs();
   init_segments();
   init_joint_functions();
   init_q_restraint_functions();
   init_motion();

   if (read_muscle_file(&sdm,"muscles.in") == code_bad)
      exit(0);

   sdm.neq = sdm.nu + sdm.nq + count_muscle_states(&sdm);

   lock = (int*)simm_malloc(sdm.nq*sizeof(int));
   y = (double*)simm_malloc(sdm.neq*sizeof(double));
   dy = (double*)simm_malloc(sdm.neq*sizeof(double));
   work = (double*)simm_malloc(6*sdm.neq*sizeof(double));
   joint_torque = (double*)calloc(sdm.nq,sizeof(double));
   joint_power = (double*)calloc(sdm.nq,sizeof(double));


   for (i=0; i<sdm.neq; i++)
      y[i] = dy[i] = 0.0;

   for (i=0; i<sdm.nq; i++)
       y[i] = sdm.q[i].initial_value/sdm.q[i].conversion;

   step = dt;


/******************* Read in Shoe Data **********************
 ************************************************************/

   fp_shoe = fopen("3dshoe.grf","r");   
   
   fscanf(fp_shoe,"%d",&sdm.num_shoe_elements);  

      for (j=0; j<sdm.num_shoe_elements; j++)
         {
         fscanf(fp_shoe,"%d %lf %lf %lf %lf %lf %lf %lf %lf %lf %lf",
			&sdm.shoe_element[j].segment,
			&sdm.shoe_element[j].coord[0],
			&sdm.shoe_element[j].coord[1],
			&sdm.shoe_element[j].coord[2],
			&sdm.shoe_element[j].param[0],
			&sdm.shoe_element[j].param[1],
			&sdm.shoe_element[j].param[2],
			&sdm.shoe_element[j].param[3],
			&sdm.shoe_element[j].param[4],
			&sdm.shoe_element[j].param[5],
			&sdm.shoe_element[j].param[6]);
         }  
    
   fclose(fp_shoe);


/******************* Read in Muscle onset/offset and **********************
 ******************* step function excitation values **********************/

   fp_exc = fopen("muscle.onset","r");      /* from optimization */

      for (j=0; j<sdm.num_muscles; j++)
         {
         fscanf(fp_exc,"%d",&sdm.muscles[j].excitation->numpoints);
      
         for (i=0; i<sdm.muscles[j].excitation->numpoints; i++)
    
            fscanf(fp_exc,"%lf %lf",&sdm.muscles[j].excitation->x[i],
                		    &sdm.muscles[j].excitation->y[i]);
         }       
   fclose(fp_exc);


/*************************************************************************  
 ********************* Inititialize Muscle Activations *******************/

   /* these values are generated by pre-integrating the muscle excitation 
      patterns from the optimization */
 
   fp_init = fopen("init.act","r");		
   
      for (j=0; j<sdm.num_muscles; j++)	
	 fscanf(fp_init,"%lf",&sdm.muscles[j].init_act);

   fclose(fp_init);
 

/************************ Read in initial state ***************************
 **************************************************************************/


/* set them by hand for now (the initial joint angles are set in init.qs)
   these values are from Andriacci's data interpolated at 1000 Hz*/
/*  
	y[sdm.nq + hip_angle_r] = 0.2175;
	y[sdm.nq + knee_angle_r] = -1.7600;
	y[sdm.nq + ankle_angle_r] = 0.4159;
	y[sdm.nq + hip_angle_l] = -0.2728;
	y[sdm.nq + knee_angle_l] = -2.6626;
	y[sdm.nq + ankle_angle_l] = -1.6451;
	y[sdm.nq + leg_tx] = 1.8439;
	y[sdm.nq + leg_ty] = -0.1094;
	y[sdm.nq + pelvis_rotation] = 0.0;
*/ 
/* read them in from the optimization */
 
   fp_state = fopen("init.state","r");
        fscanf(fp_state,"%lf ", &y[sdm.nq + hip_angle_r]);
        fscanf(fp_state,"%lf ", &y[sdm.nq + knee_angle_r]);
        fscanf(fp_state,"%lf ", &y[sdm.nq + ankle_angle_r]);
        fscanf(fp_state,"%lf ", &y[sdm.nq + hip_angle_l]);
        fscanf(fp_state,"%lf ", &y[sdm.nq + knee_angle_l]);
        fscanf(fp_state,"%lf ", &y[sdm.nq + ankle_angle_l]);
        fscanf(fp_state,"%lf ", &y[sdm.nq + leg_tx]);
        fscanf(fp_state,"%lf ", &y[sdm.nq + leg_ty]);
        fscanf(fp_state,"%lf ", &y[sdm.nq + pelvis_rotation]);
   fclose(fp_state); 	
 

/*****************************************************************************/
if (generate_motion_file == 1)
   {
   /* Open SIMM motion file for storing simulation results */

   fp_motion = fopen("motion.sd","w");
   fprintf(fp_motion,"name sd_motion\n");
   fprintf(fp_motion,"datacolumns %d\n", sdm.num_gencoords + sdm.num_muscles);
   fprintf(fp_motion,"datarows %d\n", nstep);
   fprintf(fp_motion,"range 0.0 %lf\n", nstep*dt);
   fprintf(fp_motion,"keys g_key\n");
   fprintf(fp_motion,"wrap\n");
   fprintf(fp_motion,"endheader\n\n");
   for (i=0; i<sdm.nq; i++)
      if (sdm.q[i].type == unconstrained_q)
         fprintf(fp_motion,"%s ", sdm.q[i].name);
   fprintf(fp_motion,"\n");

   for (i=0; i<sdm.num_muscles; i++)
      fprintf(fp_motion,"%s ", sdm.muscles[i].name);
   fprintf(fp_motion,"\n");
   }


   sdinit();

   for (i=0; i<sdm.nq; i++)
   {
      if (sdm.q[i].type == prescribed_q)
         lock[i] = 1;
      else
         lock[i] = 0;
   }

   sdassemble(t,y,lock,ctol,500,&fcnt,&err);
   if (err != 0)
   {
      fprintf(stderr,"Assembly failed, err = %d\n", err);
      fprintf(stderr,"Closest solution:\n");
      for (i=0; i<sdm.nq; i++)
         if (sdm.q[i].type == unconstrained_q)
            fprintf(stderr,"%8.3lf ", y[i]*sdm.q[i].conversion);
      fprintf(stderr,"\n");
      exit(0);
   }
   if (verify_assembly(&sdm,y) == code_bad)
      exit(0);


   sdinitvel(t,y,lock,ctol,500,&fcnt,&err);
   if (err != 0)
   {
      fprintf(stderr,"Velocity analysis failed\n");
      exit(0);
   }

   printf("System assembled.\nBeginning simulation...\n\n");
   /*
   printf("Qs: ");
   for (i=0; i<sdm.nq; i++)
      if (sdm.q[i].type == unconstrained_q)
         printf("%s ", sdm.q[i].name);
   printf("\n\n");
   */
   /* Set the Baumgarte stabilization constants. This type of
    * stabilization should help reduce the errors from constraint
    * violations. The position and velocity errors are multiplied by
    * constants so that the integrator "takes them more seriously."
    * The first argument to sdstab() is for position, the second one
    * is for velocity. Feel free to adjust the value of BAUMGARTE_STAB
    * if the integration still involves high errors or is proceeding
    * too slowly. Set the value to 0 to turn off stabilization.
    */

   sdstab(2*BAUMGARTE_STAB,BAUMGARTE_STAB*BAUMGARTE_STAB);

   sdstate(t,y,&y[sdm.nq]);

   init_muscle_states(&sdm,y);

   fp_sim= fopen("sim.dat","w");
   fp_pwr= fopen("muscle_l.pwr","w");

   tx_var = 0.0;

   for (i=0; i<nstep; i++)
   {

/* Reset the leg displacement for the muscle excitation patterns */

   if (y[leg_tx] > 1.67)
	{
	y[leg_tx] -= 1.67;
	tx_var = 1.67;
	}
	
      for (j=0; j<sdm.num_muscles; j++)
         sdm.muscles[j].excitation_level = calc_excitation(&sdm.muscles[j],t,y);

      calc_derivatives(t,y,dy,param,&err);

      sdvinteg(calc_derivatives,&t,y,dy,param,dt,&step,sdm.neq,
	       tol,work,&err,&which);


      if (err != 0)
      {
         printf("Simulation stopped:\n");
         if (err == 3)
            printf("%s out of range. value = %lf, range = %lf to %lf\n",
		   sdm.q[which-1].name, y[which-1]*sdm.q[which-1].conversion,
		   sdm.q[which-1].range_start, sdm.q[which-1].range_end);
         else
            printf("sdvinteg error status %d, error number %d\n", err, which);
         break;
      }

      assign_muscle_states(&sdm,t,y);

/*** compute system mechanical energy ***/

      for(j=0;j<3;j++)
         zero[j]=0.0;

      for(j=0;j<NBOD;j++)
         {
         sdgetiner(j,inertemp);
            inertia[j] =inertemp[2][2];
         sdgetmass(j,&masstemp);
            mass[j] =  masstemp;
         sdvel(j,zero,veltemp);
            vel[j][0] = veltemp[0];
            vel[j][1] = veltemp[1];
         sdangvel(j,angveltemp);
            angvel[j] = angveltemp[2];
	 sdpos(j,zero,postemp);
	    pos[j] = postemp[1];
         }

      segment_me(segme_total, inertia, mass, vel, angvel, pos);


/******* Compute net joint moments */

   calc_joint_torques(t, y, dy, joint_torque);

   calc_joint_powers(joint_torque, joint_power);


   for (j=0; j<NMUS; j++)
      {
      ms = &sdm.muscles[j]; 
      mus_pwr[i][j] = sdm.muscles[j].force*calc_muscle_tendon_velocity(ms);
      }



if (generate_motion_file == 1)
   {
      /* Write Qs and muscle activations to a SIMM motion file */

      for (j=0; j<sdm.nq; j++)
         if (sdm.q[j].type == unconstrained_q)
	    if (j == leg_tx)
               fprintf(fp_motion,"%9.4lf ", y[j]*sdm.q[j].conversion+tx_var);
	    else
	       fprintf(fp_motion,"%9.4lf ", y[j]*sdm.q[j].conversion);
	 
      for (j=0; j<sdm.num_muscles; j++)
         fprintf(fp_motion,"%7.5lf ", sdm.muscles[j].dynamic_activation);
      fprintf(fp_motion,"\n");
      fflush(fp_motion);
   }



/* Sum GRF forces over all right shoe elements */

      for (j=0; j<sdm.num_shoe_elements/2; j++)
	 {
	  ss = &sdm.shoe_element[j];
	  grf[i][0]+=ss->grf[0]/(9.81*75.1282);
	  grf[i][1]+=ss->grf[1]/(9.81*75.1282);
	  grf[i][2]+=ss->grf[2]/(9.81*75.1282);
	 }
      for (j=sdm.num_shoe_elements/2; j<sdm.num_shoe_elements; j++)
	 {
	  ss = &sdm.shoe_element[j];
	  grf[i][3]+=ss->grf[0]/(9.81*75.1282);
	  grf[i][4]+=ss->grf[1]/(9.81*75.1282);
	  grf[i][5]+=ss->grf[2]/(9.81*75.1282);
	 }

/* Compute the left ankle angular velocity */
        
      sdangvel(tibia_l,temp2);
      sdangvel(calcn_l,temp3);

      ankavel=temp3[2]-temp2[2];


/* Save tracking array to write to file later */

	track[i][0] = y[hip_angle_r]*sdm.q[hip_angle_r].conversion;
	track[i][1] = y[knee_angle_r]*sdm.q[knee_angle_r].conversion;
	track[i][2] = y[ankle_angle_r]*sdm.q[ankle_angle_r].conversion;
	track[i][3] = y[hip_angle_l]*sdm.q[hip_angle_l].conversion;
	track[i][4] = y[knee_angle_l]*sdm.q[knee_angle_l].conversion;
	track[i][5] = y[ankle_angle_l]*sdm.q[ankle_angle_l].conversion;
	track[i][6] = y[leg_tx]+tx_var;
	track[i][7] = y[leg_ty];
	track[i][8] = grf[i][1];
	track[i][9] = joint_torque[hip_angle_l]/75.1282;
	track[i][10] = joint_torque[knee_angle_l]/75.1282;
	track[i][11] = joint_torque[ankle_angle_l]/75.1282;
	track[i][12] = grf[i][4];
	track[i][13] = joint_power[hip_angle_l]/75.1282;
	track[i][14] = joint_power[knee_angle_l]/75.1282;
	track[i][15] = joint_power[ankle_angle_l]/75.1282;
	track[i][16] = grf[i][3];
	track[i][17] = ankavel;
	track[i][18] = segme_total[1];
	track[i][19] = segme_total[2];



   } /* end of iteration loop */


/*** Write tracking array ***/

   for (i=0; i<nstep; i+=5)
      {  
      fprintf(fp_sim,"%lf ",(i+1)*dt);
      for (j=0; j<20; j++)
         fprintf(fp_sim,"%lf ",track[i][j]);
      fprintf(fp_sim,"\n");
      }

/* Write muscle power file */

   for (i=0; i<nstep; i+=5)
      {  
      fprintf(fp_pwr,"%lf %lf %lf %lf %lf %lf %lf %lf %lf %lf \n",(i+1)*dt, 
         mus_pwr[i][sol_l],mus_pwr[i][medgas_l]+mus_pwr[i][latgas_l],
         mus_pwr[i][sm_l]+mus_pwr[i][bflg_l],mus_pwr[i][bfsh_l],
         mus_pwr[i][psoas_l]+mus_pwr[i][iliac_l],mus_pwr[i][ta_l],
         mus_pwr[i][rf_l],mus_pwr[i][vas1_l]+mus_pwr[i][vas2_l]+mus_pwr[i][vas3_l],
         mus_pwr[i][gmax_l]+mus_pwr[i][addmag_l]);
      }

   fclose(fp_pwr);
   fclose(fp_sim);
   fclose(fp_motion);

   sdprinterr(stdout);

}



/***************************************************************************/
/* APPLY_PASSIVE_JOINT_TORQUES: applies passive joint torques based on Davy 
 * and Audu (1987).*/

void apply_passive_joint_torques(SDModelStruct* sdm, double q[], double u[])
{

double passive_trq;


/****** Apply passive joint torques ******/


/* Pelvis 
   
   passive_trq = (10000.0*q[pelvis_rotation] + 2000.0*u[pelvis_rotation]);

   sdhinget(pelvis,2,-passive_trq);
*/

/* Ankle joints */

       
   passive_trq = (2.0*exp(-5.0*(q[ankle_angle_r]+0.5236))
	          -9.0*exp(-5.0*(0.3491-q[ankle_angle_r]))
		  -0.943*u[ankle_angle_r]);
   sdhinget(ankle_r,0,passive_trq);

   passive_trq = (2.0*exp(-5.0*(q[ankle_angle_l]+0.5236))
	          -9.0*exp(-5.0*(0.3491-q[ankle_angle_l]))
		  -0.943*u[ankle_angle_l]);
   sdhinget(ankle_l,0,passive_trq);

 
/* Knee joints */
  
   passive_trq =  (3.1*exp(-5.9*(q[knee_angle_r]+1.92))
	          -10.5*exp(-11.8*(-0.1-q[knee_angle_r]))
		  -1.0*u[knee_angle_r]);
   sdhinget(knee_r,2,passive_trq);

   passive_trq =  (3.1*exp(-5.9*(q[knee_angle_l]+1.92))
	          -10.5*exp(-11.8*(-0.1-q[knee_angle_l]))
		  -1.0*u[knee_angle_l]);
   sdhinget(knee_l,2,passive_trq);
 

/* Hip joints */
  
   passive_trq = (2.6*exp(-5.8*(q[hip_angle_r]-0.1745))
	          -8.7*exp(-1.3*(1.92-q[hip_angle_r]))
		  -1.09*u[hip_angle_r]);
   sdhinget(hip_r,0,passive_trq);

   passive_trq = (2.6*exp(-5.8*(q[hip_angle_l]-0.1745))
	          -8.7*exp(-1.3*(1.92-q[hip_angle_l]))
		  -1.09*u[hip_angle_l]);
   sdhinget(hip_l,0,passive_trq);
}


/* SDUMOTION: this routine specifies the prescribed motion for
 * fixed joints, which are implemented as prescribed pins.
 */

int sdumotion(double t, double q[], double u[])
{

   prescribe_fixed_joints(&sdm);

}



/* SDUFORCE: this routine is used to apply forces to the body segments.
 * By default, it contains only two routines: the one that applies muscle
 * forces and the one that applies joint restraint forces. If you want to
 * apply other external forces to the segments, you can add in your own
 * code here. If the forces or torques you want to apply have been
 * pre-calculated for each time step, you can use load_motion_data() to
 * read them in, then use apply_external_forces() to apply them (just like
 * with inverse dynamics).
 */

int sduforce(double t, double q[], double u[])
{
   apply_muscle_forces(&sdm);
 
   apply_ground_contact_forces(&sdm);
 
   apply_passive_joint_torques(&sdm,q,u);

}



/* INIT_MOTION: this routine turns off prescribed motion for all
 * unconstrained q's. It does not set the constrained q's because
 * in the SD/FAST system description file they were set with
 * "prescribed = 0".  It does not need to turn on prescribed motion
 * for [tree] weld joints, which are implemented as prescribed pins,
 * because they are set with "prescribed = 1" in the system description
 * file.
 */

static void init_motion(void)
{

   set_prescribed_motion(&sdm,unconstrained_q,0);

}


/***************************************************************************/
/*  CALC_JOINT_TORQUES based on a routine by Lisa Schutte and Chris Raasch
 *  --> it calculates total joint torques applied during motion */

void calc_joint_torques(double t,double y[],double ydot[],double joint_torque[])

{
  double q[NQ],u[NU],udot[NU],mult[NC];
  double omega,pv[3];
  int i,rk,multmap[NC],err,routine;
  
  sdclearerr();

  for(i=0;i<NQ;i++)
  {
    q[i] = y[i];
    u[i] = y[NQ+i];
    udot[i] = ydot[NQ+i];
  }

  sdmult(mult,&rk,multmap);
  sdstate(t,q,u);
  apply_ground_contact_forces(&sdm);
  /*apply_passive_joint_torques(&sdm,q,u);*/
  sdfulltrq(udot,mult,joint_torque);
  

/* Calculate knee torque due to translational and patella forces.
 * pv[] is partial velocity of the knee trans. or patella DOF; the
 * joint force for that DOF is multiplied by each partial velocity to
 * get the torque at the knee instantaneous center of rotation (icr)
 */

  omega = y[knee_angle_r+NQ];
  if( EQUAL_WITHIN_ERROR(omega,0.0) )
    pv[0] = 0.0;
  else
  {
    /* knee tx and ty */
    pv[0] = u[knee_r_tx]/omega;
    pv[1] = u[knee_r_ty]/omega;
    joint_torque[knee_angle_r] += joint_torque[knee_r_tx]*pv[0] +
                                  joint_torque[knee_r_ty]*pv[1];
    /* patella */
    pv[0] = u[tib_pat_r_tx]/omega;
    pv[1] = u[tib_pat_r_ty]/omega;
    pv[2] = u[tib_pat_r_r3]/omega;
    joint_torque[knee_angle_r] += joint_torque[tib_pat_r_tx]*pv[0] + 
                                  joint_torque[tib_pat_r_ty]*pv[1] +
				  joint_torque[tib_pat_r_r3]*pv[2];
  }

  omega = y[knee_angle_l+NQ];
  if( EQUAL_WITHIN_ERROR(omega,0.0) )
    pv[0] = 0.0;
  else
  {
    /* knee tx and ty */
    pv[0] = u[knee_l_tx]/omega;
    pv[1] = u[knee_l_ty]/omega;
    joint_torque[knee_angle_l] += joint_torque[knee_l_tx]*pv[0] +
                                  joint_torque[knee_l_ty]*pv[1];
    /* patella */
    pv[0] = u[tib_pat_l_tx]/omega;
    pv[1] = u[tib_pat_l_ty]/omega;
    pv[2] = u[tib_pat_l_r3]/omega;
    joint_torque[knee_angle_l] += joint_torque[tib_pat_l_tx]*pv[0] + 
                                  joint_torque[tib_pat_l_ty]*pv[1] +
				  joint_torque[tib_pat_l_r3]*pv[2];
  }

  
  sderror(&routine,&err);  /*Check for errors */

  if(err!=0)
    printf("Error %2i occurred in routine %2i\n",err,routine);

  }

/*************************************************************************/
/*  CALC_JOINT_POWERS  --> it calculates sagittal plane total joint powers 
    applied during motion */

void calc_joint_powers(double joint_torque[], double joint_power[])

{
  
  double temp1[3], temp2[3], temp3[3], temp4[3];
  double hipavel, kneavel, ankavel;
  int err,routine;

  /* Right Leg */

      sdangvel(femur_r,temp1);            
      sdangvel(tibia_r,temp2);
      sdangvel(talus_r,temp3);
      sdangvel(pelvis,temp4);

      hipavel=temp1[2]-temp4[2];
      kneavel=temp2[2]-temp1[2];
      ankavel=temp3[2]-temp2[2];

      joint_power[hip_angle_r] = joint_torque[hip_angle_r]*hipavel;
      joint_power[knee_angle_r] = joint_torque[knee_angle_r]*kneavel;
      joint_power[ankle_angle_r] = joint_torque[ankle_angle_r]*ankavel;


  /* Left Leg */

      sdangvel(femur_l,temp1);            
      sdangvel(tibia_l,temp2);
      sdangvel(talus_l,temp3);
 
      hipavel=temp1[2]-temp4[2];
      kneavel=temp2[2]-temp1[2];
      ankavel=temp3[2]-temp2[2];

      joint_power[hip_angle_l] = joint_torque[hip_angle_l]*hipavel;
      joint_power[knee_angle_l] = joint_torque[knee_angle_l]*kneavel;
      joint_power[ankle_angle_l] = joint_torque[ankle_angle_l]*ankavel;

  
  sderror(&routine,&err);  /*Check for errors */

  if(err!=0)
    printf("Error %2i occurred in routine %2i\n",err,routine);

}


/***************************************************************************/
/* CALC_NET_GRFS: this routine computes the net ground reaction forces and 
   center-of-pressure (cop). */

void calc_net_grfs(SDModelStruct* sdm, double y[], double dy[], double netgrf[], double cop[])  
{
   int i,j;
   double sum[12];
   ShoeStruct* ss;

   /* Sum GRF forces over all right and left shoe elements */

      for (j=0; j<12; j++)
         {
         netgrf[j]=0.0;
         sum[j]=0.0;
         cop[j]=0.0;
	 }

      /********* Compute the net grf for the right foot ********/

      for (i=0; i<sdm->num_shoe_elements; i++)
	{
	ss = &sdm->shoe_element[i];
	  
	if (ss->segment == calcn_r)
	     	{
	  	netgrf[0] += ss->grf[0];
	  	netgrf[1] += ss->grf[1];
	  	netgrf[2] += ss->grf[2];

		sum[0] += ss->coord[0]*ss->grf[1];
	  	sum[1] += ss->coord[1]*ss->grf[0];
	      	}

	if (ss->segment == calcn_l)
	     	{
	  	netgrf[3] += ss->grf[0];
	  	netgrf[4] += ss->grf[1];
	  	netgrf[5] += ss->grf[2];

		sum[3] += ss->coord[0]*ss->grf[1];
	  	sum[4] += ss->coord[1]*ss->grf[0];
	      	}

	 }


   /* Compute the center of pressure for calcn_r */

	  if(netgrf[1] == 0.0)
	     cop[0] = 0.0;
	  else
	     cop[0] = sum[0]/netgrf[1];

	  if(netgrf[0] == 0.0)
	     cop[1] = 0.0;
	  else
	     cop[1] = sum[1]/netgrf[0];

   /* Compute the center of pressure for calcn_l */

	  if(netgrf[4] == 0.0)
	     cop[3] = 0.0;
	  else
	     cop[3] = sum[3]/netgrf[4];

	  if(netgrf[3] == 0.0)
	     cop[4] = 0.0;
	  else
	     cop[4] = sum[4]/netgrf[3];


}/* end of the routine */


/***************************************************************************/
/*  SEGMENT_ME  --> it calculates the mechanical energy of individual segments */

void segment_me(double segme[], double inertia[], double mass[],
         double vel[][3], double angvel[], double pos[])
{
   int i;
   double zero[3], acc[3], angacc[3];
   double gravity=9.80665, me[NBOD], mer[NBOD], meh[NBOD], mev[NBOD];

   /* Set array defining the center of mass of each body */

   for(i=0;i<3;i++)
      zero[i]=0.0;

   /* For each body, compute the segment me (BJ's Dissertation pg.85) */

   for(i=0;i<NBOD;i++)
      {
      sdacc(i,zero,acc);
      sdangacc(i,angacc);

      me[i] = 0.5*inertia[i]*angvel[i]*angvel[i]
                   + 0.5*mass[i]*vel[i][0]*vel[i][0]
                   + 0.5*mass[i]*vel[i][1]*vel[i][1]
                   + mass[i]*gravity*pos[i];

      /* mer[i] = 0.5*inertia[i]*angvel[i]*angvel[i]; */
      mer[i] = mass[i]*gravity*pos[i];;

      meh[i] = 0.5*mass[i]*vel[i][0]*vel[i][0];

      mev[i] = 0.5*mass[i]*vel[i][1]*vel[i][1];

      }
   
/* Sum segment meer components of interest for the segments */
 
   /* pelvis, right leg, left leg */

      segme[0] = me[pelvis];                  
      segme[1] = me[femur_r]+me[tibia_r]+me[patella_r]+me[talus_r]+me[calcn_r];
      segme[2] = me[femur_l]+me[tibia_l]+me[patella_l]+me[talus_l]+me[calcn_l];                       

/* break the pelvis segment ME components up */

    /* pelvis rotational */
	segme[3] = mer[pelvis];

    /* pelvis horizontal */
	segme[4] = meh[pelvis];

    /* pelvis vertical */
	segme[5] = mev[pelvis];


/* break the right and left leg segment ME components up */

    /* right leg rotational */
	segme[6] = mer[femur_r]+mer[tibia_r]+mer[patella_r]+mer[talus_r]+mer[calcn_r];

    /* right leg horizontal */
	segme[7] = meh[femur_r]+meh[tibia_r]+meh[patella_r]+meh[talus_r]+meh[calcn_r];

    /* right leg vertical */
	segme[8] = mev[femur_r]+mev[tibia_r]+mev[patella_r]+mev[talus_r]+mev[calcn_r];

    /* left leg rotational */
	segme[9] = mer[femur_l]+mer[tibia_l]+mer[patella_l]+mer[talus_l]+mer[calcn_l];

    /* left leg horizontal */
	segme[10] = meh[femur_l]+meh[tibia_l]+meh[patella_l]+meh[talus_l]+meh[calcn_l];

    /* left leg vertical */
	segme[11] = mev[femur_l]+mev[tibia_l]+mev[patella_l]+mev[talus_l]+mev[calcn_l];
}
